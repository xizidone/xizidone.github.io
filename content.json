{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Xizi","url":"http://colorfuwp.top","root":"/"},"pages":[{"title":"about","date":"2023-01-07T09:45:53.000Z","updated":"2023-01-08T05:51:00.292Z","comments":false,"path":"about/index.html","permalink":"http://colorfuwp.top/about/index.html","excerpt":"","text":"使用Hexo快速搭建的个人博客,主题采用Fluid。"}],"posts":[{"title":"测试文章","slug":"测试文章","date":"2023-08-20T16:00:00.000Z","updated":"2023-01-08T06:20:04.597Z","comments":true,"path":"2023/08/21/测试文章/","link":"","permalink":"http://colorfuwp.top/2023/08/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","excerpt":"","text":"1代码块","categories":[{"name":"Redis","slug":"Redis","permalink":"http://colorfuwp.top/categories/Redis/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://colorfuwp.top/tags/Spring/"},{"name":"底层原理","slug":"底层原理","permalink":"http://colorfuwp.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"Java8","slug":"Java8","permalink":"http://colorfuwp.top/tags/Java8/"}]},{"title":"SpringBoot实现文件上传下载功能","slug":"SpringBoot实现文件上传下载功能","date":"2022-12-22T16:00:00.000Z","updated":"2023-01-08T06:09:39.789Z","comments":true,"path":"2022/12/23/SpringBoot实现文件上传下载功能/","link":"","permalink":"http://colorfuwp.top/2022/12/23/SpringBoot%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/","excerpt":"","text":"配置和前端页面 maven配置文件 123456789101112&lt;dependencies&gt; &lt;!-- web模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- thymeleaf 模板引擎 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 前端页面 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.5.0/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;文件上传&lt;/h3&gt;&lt;!--文件上传要求form表单的请求方式必须为post，并且添加属性enctype=\"multipart/form-data\"--&gt;&lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\" &gt; &lt;br&gt; &lt;input type=\"submit\" value=\"上传\" &gt;&lt;/form&gt;[[${filename}]]&lt;br&gt;&lt;!--渲染上传的图片--&gt;&lt;img th:src=\"@{${filename}}\" alt=\"图片\" id=\"imgss\"&gt;&lt;h3&gt;文件下载&lt;/h3&gt;&lt;form action=\"/download\" method=\"get\"&gt; &lt;input type=\"hidden\" name=\"imageName\" id=\"imageName\" th:value=\"${filename}\"/&gt; &lt;input type = \"submit\" value=\"点击图片下载\" &gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; webconfig配置 1234567891011@Configurationpublic class MyWebAppConfigurer implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { // 用于前端匹配路径 /AAA-uploaded/** 的时候 可以直接定位到D://AAA-uploaded/图片存储的地址 // 用于前端页面渲染图片 registry.addResourceHandler(\"/AAA-uploaded/**\"). addResourceLocations(\"file:/\" + \"D://AAA-uploaded/\"); }} yaml配置文件 12345server: port: 8080my-config: file-path: D:\\ 文件上传功能 MultipartFile接收前端传来的文件 12345678910111213141516171819202122232425@Value(\"${my-config.file-path}\") private String myFilePath; @RequestMapping(\"upload\") public String upload(@RequestParam(\"file\") MultipartFile file, Model model) { try { // 避免图片名字重复 采用时间戳+图片名 String fileName = System.currentTimeMillis() + file.getOriginalFilename(); // 获取图片存放路径 String destFileName = myFilePath + \"AAA-uploaded\" + File.separator + fileName; File destFile = new File(destFileName); // 判断上一级目录是否存在 不存在则创建 if (!destFile.getParentFile().exists()) { destFile.getParentFile().mkdirs(); } // 移动文件到指定目录下 file.transferTo(destFile); // 存放到页面用于回显测试 model.addAttribute(\"filename\", \"AAA-uploaded/\" + fileName); } catch (Exception e) { e.printStackTrace(); return \"上传失败,\" + e.getMessage(); } return \"index\"; } 文件下载功能 ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文 1234567891011121314151617181920212223242526272829@Value(\"${my-config.file-path}\") private String myFilePath;@ResponseBody @RequestMapping(\"/download\") public ResponseEntity&lt;byte[]&gt; testResponseEntity(@RequestParam(value = \"imageName\", required = false) String filename) throws IOException { // 获取图片名称返回给页面用于下载 String name = filename.split(\"/\")[1]; File newfile = new File(\"D:/AAA-uploaded\" + File.separator + name); if (!newfile.exists()) { throw new IOException(name + \"文件不存在\"); } // 创建输入流 InputStream is = new FileInputStream(newfile); // 创建字节数组 byte[] bytes = new byte[is.available()]; // 将流读到字节数组中 is.read(bytes); // 创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); // 设置要下载方式以及下载文件的名字 headers.add(\"Content-Disposition\", \"attachment;filename=\"+ name); // 设置响应状态码 HttpStatus statusCode = HttpStatus.OK; // 创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode); // 关闭输入流 is.close(); return responseEntity; }","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://colorfuwp.top/categories/SpringBoot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://colorfuwp.top/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://colorfuwp.top/tags/SpringBoot/"}]},{"title":"Jackson序列化方式实现数据脱敏","slug":"Jackson序列化方式实现数据脱敏","date":"2022-08-20T16:00:00.000Z","updated":"2023-01-08T06:20:04.607Z","comments":true,"path":"2022/08/21/Jackson序列化方式实现数据脱敏/","link":"","permalink":"http://colorfuwp.top/2022/08/21/Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/","excerpt":"","text":"方案选择 基于Mybatis 的拦截器：对select 语句进行拦截数据脱敏，但是存在问题 在某些业务中对数据脱敏字段是需要进行逻辑业务处理的 基于Jaskson 序列化：针对需要展示在前端的数据 通常我们都是对应一个ＶＯ对象，这里可以在将ＶＯ对象返回给前端序列化时进行数据的脱敏 实现方案1.自定义序列化器 覆盖原来的序列化方式12345678910111213141516171819202122232425262728293031323334353637383940 需要引入jackson依赖 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt;/** * 脱敏序列化器 */public class ObjectDesensitizeSerializer extends StdSerializer&lt;Object&gt; implements ContextualSerializer { protected ObjectDesensitizeSerializer() { super(Object.class); } @Override public JsonSerializer&lt;Object&gt; createContextual(SerializerProvider prov, BeanProperty property) { // 这里创建序列化上下文环境 以选择是否需要指定返回不同的序列化器 return serializer; } @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { // 这里编写实际序列化的字段的处理 }} 2.定义策略类(处理实际脱敏逻辑)然后针对不同的字段会有不同的脱敏方案 比如 身份证号 银行卡号 电话号码等 这里采用 策略模式 + 工厂模式 进行解耦，符合开闭原则 定义一个顶级接口 然后多个实现 12345678910111213141516171819202122232425262728293031323334353637/** * 定义一个 顶级的脱敏器 */public interface Desensitization&lt;T&gt; { /** * 脱敏实现 * * @param target 脱敏对象 * @return 脱敏返回结果 */ T desensitize(T target);}// 多接口实现/** * 字符串脱敏器 */public interface StringDesensitization extends Desensitization&lt;String&gt; {}/** * 身份证(18位和15位) 脱敏器 */public class IDCardDesensitization implements StringDesensitization {}/** * 邮箱脱敏器 默认只保留域名 */public class EmailDesensitization implements StringDesensitization {} 这里只展示具体的一个脱敏实现 其他都是类似 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 手机号脱敏器 默认只保留前3位和后4位 */public class PhoneDesensitization implements StringDesensitization { /** * 手机号正则 */ private static final Pattern DEFAULT_PATTERN = Pattern.compile(\"(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\\\d{8}\"); /** * 手机号脱敏 只保留前3位和后4位 */ @Override public String desensitize(String target) { // 匹配判断是否符合正则 Matcher matcher = DEFAULT_PATTERN.matcher(target); while (matcher.find()) { String group = matcher.group(); // 调用方法进行脱敏 target = target.replace(group, group.substring(0, 3) + Symbol.getSymbol(4, Symbol.STAR) + group.substring(7, 11)); } return target; }}public class Symbol { /** * '*'脱敏符 */ public static final String STAR = \"*\"; private Symbol() { } /** * 获取符号 * * @param number 符号个数 * @param symbol 符号 */ public static String getSymbol(int number, String symbol) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; number; i++) { sb.append(symbol); } return sb.toString(); }} 3.定义工厂类 获取实际策略 并缓存策略上述是 策略模式的体现 ，策略模式 通常结合工厂模式 屏蔽创建对象细节 直接通过工厂创建指定的策略类 1234567891011121314151617181920212223242526272829/** *策略类的工厂 */public class DesensitizationFactory { private DesensitizationFactory() { } // 这里采用一个 Map 集合 对指定的策略类进行缓存 避免对象的重复创建 private static final Map&lt;Class&lt;?&gt;, Desensitization&lt;?&gt;&gt; map = new HashMap&lt;&gt;(); @SuppressWarnings(\"all\") public static Desensitization&lt;?&gt; getDesensitization(Class&lt;?&gt; clazz) { // 如果传递的只是接口 不是实现类 则抛出异常 if (clazz.isInterface()) { throw new UnsupportedOperationException(\"desensitization is interface, what is expected is an implementation class !\"); } return map.computeIfAbsent(clazz, k -&gt; { try { // 返回指定 Class 的策略类 同时缓存在 Map 中 return (Desensitization&lt;?&gt;) clazz.newInstance(); } catch (InstantiationException | IllegalAccessException e) { throw new UnsupportedOperationException(e.getMessage(), e); } }); }} 4.定义注解 简化使用然后就是注解的定义，利用注解 直接对 VO 对象的字段标记，无代码入侵 1234567891011121314151617181920/** * 对象脱敏 注解 */@Target({ElementType.FIELD, ElementType.ANNOTATION_TYPE}) // 作用于注解类型上 供其他注解使用@Retention(RetentionPolicy.RUNTIME)@JacksonAnnotationsInside // 组合注解 将多个注解拼在一起使用@JsonSerialize(using = ObjectDesensitizeSerializer.class) // 标记序列化配置中 使用哪个类序列化 这里指定之前定义的ObjectDesensitizeSerializer@Documentedpublic @interface Desensitize { // 这里对应了工厂类中的Class类型 以及在 ObjectDesensitizeSerializer 中创建上下文环境时 可供获取的参数去选择实际的脱敏方式 /** * 对象脱敏器实现 */ @SuppressWarnings(\"all\") Class&lt;? extends Desensitization&lt;?&gt;&gt; desensitization();} 然后就是对应的实际字段注解 123456789101112131415161718192021/** * 电话脱敏 注解 */@Target({ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@JacksonAnnotationsInside@Desensitize(desensitization = PhoneDesensitization.class) // 这里指定执行脱敏逻辑的类@Documentedpublic @interface PhoneDesensitize {}/** * 中华人民共和国身份证 脱敏注解 */@Target({ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@JacksonAnnotationsInside@Desensitize(desensitization = IDCardDesensitization.class) // 这里指定执行脱敏逻辑的类@Documentedpublic @interface IDCardDesensitize {} 5.完善自定义序列化器的逻辑最后就是回到开头 编写实际的 自定义序列化器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667** * 脱敏序列化器 */public class ObjectDesensitizeSerializer extends StdSerializer&lt;Object&gt; implements ContextualSerializer { // 面向接口 根据策略不同而实际 set 不同的 脱敏类 private transient Desensitization&lt;Object&gt; desensitization; protected ObjectDesensitizeSerializer() { super(Object.class); } public Desensitization&lt;Object&gt; getDesensitization() { return desensitization; } public void setDesensitization(Desensitization&lt;Object&gt; desensitization) { this.desensitization = desensitization; } // 创建上下文环境 @Override public JsonSerializer&lt;Object&gt; createContextual(SerializerProvider prov, BeanProperty property) { // 根据 BeanProperty 获取被标记 VO 字段的注解上的 实际策略脱敏类 Desensitize annotation = property.getAnnotation(Desensitize.class); return createContextual(annotation.desensitization()); } @SuppressWarnings(\"unchecked\") public JsonSerializer&lt;Object&gt; createContextual(Class&lt;? extends Desensitization&lt;?&gt;&gt; clazz) { ObjectDesensitizeSerializer serializer = new ObjectDesensitizeSerializer(); // 判断是否属于 StringDesensitization 因为 StringDesensitization 属于全脱敏 if (clazz != StringDesensitization.class) { // 不属于则 回到上面 通过工厂类去创建脱敏类 serializer.setDesensitization((Desensitization&lt;Object&gt;) DesensitizationFactory.getDesensitization(clazz)); } return serializer; } // 创建完 上下文环境 返回 serializer 执行序列化 serialize @Override public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { Desensitization&lt;Object&gt; objectDesensitization = getDesensitization(); // 获取 策略类（即 前面 set 的 desensitization） if (objectDesensitization != null) { try { // 不为空调用处理脱敏逻辑 gen.writeObject(objectDesensitization.desensitize(value)); } catch (Exception e) { gen.writeObject(value); } } else if (value instanceof String) { // 为空 说明是 StringDesensitization 且字段是 String 类型 则 全脱敏 gen.writeString(Symbol.getSymbol(((String) value).length(), Symbol.STAR)); } else { // 否则 正常序列化 gen.writeObject(value); } }} 最终可达到 一个注解 即可脱敏","categories":[{"name":"三方包","slug":"三方包","permalink":"http://colorfuwp.top/categories/%E4%B8%89%E6%96%B9%E5%8C%85/"}],"tags":[{"name":"自定义注解","slug":"自定义注解","permalink":"http://colorfuwp.top/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"name":"Java","slug":"Java","permalink":"http://colorfuwp.top/tags/Java/"},{"name":"三方包","slug":"三方包","permalink":"http://colorfuwp.top/tags/%E4%B8%89%E6%96%B9%E5%8C%85/"}]},{"title":"Redis的实现简易限流的两种方案(基于自定义注解+SpringBoot拦截器）","slug":"Redis的实现简易限流的两种方案","date":"2022-08-14T16:00:00.000Z","updated":"2023-01-08T06:20:04.589Z","comments":true,"path":"2022/08/15/Redis的实现简易限流的两种方案/","link":"","permalink":"http://colorfuwp.top/2022/08/15/Redis%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E9%99%90%E6%B5%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88/","excerpt":"","text":"一、基于Redis的 String 结构这里为什么会想到实现这个功能，首先是前段时间看到有人恶意访问博客的评论接口，大量刷取评论，一秒钟请求了上千次写数据库的操作，由于博客网站也是比较简陋，果然项目只有跑起来的时候才是最舒服的，后续基本也没有维护(博客也基本没有再写了)，当时就只是把这几千条数据删除了。这几天看代码的时候，看到了Redis部分的代码，加上实习公司月度技术分享的时候 展示了一下自定义注解配合拦截器，让我想到也可以通过自定义注解 加 Redis 实现，顺便学习一波注解相关知识。 先说一下最基本思路：使用Redis String 结构，key 存储用户ip，value 存储访问次数 配合一个过期时间，然后取出访问次数，超出访问次数就禁止访问。 代码实现： 1.首先实现自定义注解123456789101112131415161718192021// 三个元注解 @Target(ElementType.METHOD) // 作用于方法上@Retention(RetentionPolicy.RUNTIME) // 保留注解到运行时@Documented // 生产文档注解 (可忽略)public @interface AccessLimit { // 定义的两个注解参数 /** * 最大允许访问数量 */ int maxCount(); /** * 单位时间(秒) * @return */ int seconds();}// 使用 直接作用在方法上 填入参数@AccessLimit(maxCount = 2,seconds = 20) 2.然后实现 SpringBoot 自带的 HandlerInterceptor 接口 (这里也可以采用 AOP 的方式切入)123456789101112// 标记为Spirng 组件@Componentpublic class WebSecurityInterceptor implements HandlerInterceptor { // 重写 preHandle 在方法执行之前拦截 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 等会这里重写逻辑 return true; }} 3.然后还需要将该拦截器添加到配置中12345678910111213141516// 采用配置类@Configurationpublic class WebConfig implements WebMvcConfigurer { @Resource private WebSecurityInterceptor webSecurityInterceptor; // 添加拦截器 (如果多个拦截器 会按照添加顺序进行拦截) @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(webSecurityInterceptor); }} 4.最后就是 实现 Redis String 限流方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 在刚刚重写的方法中@Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 判断是否属于方法handler if (handler instanceof HandlerMethod) { // 获取判断是否含有注解 AccessLimit accessLimit = ((HandlerMethod) handler).getMethodAnnotation(AccessLimit.class); // 没有注解标记 直接返回允许通行 if (accessLimit == null) { return true; } // 取出注解参数 int maxCount = accessLimit.maxCount(); int seconds = accessLimit.seconds(); // 获取当前访问用户的ip 实现对用户级别的限流 String ip = request.getRemoteAddr(); // 以访问路径和用户ip拼接key String key = request.getServletPath() + ip; // 从redis 中获取当前用户记录 Integer count = (Integer) redisTemplate.opsForValue().get(key); // 如果第一次访问 if (count == null || count == -1) { // 设置为一 并设置时间 redisTemplate.opsForValue().set(key, 1, seconds, TimeUnit.SECONDS); return true; } // 如果小于 则直接加一 if (count &lt; maxCount) { redisTemplate.opsForValue().increment(key, 1); return true; } // 大于 限流 返回错误信息 render(response, new R().fail(\"操作过于频繁,请稍后再试\")); return false; } return true; } /** * 给页面返回错误信息 */ private void render(HttpServletResponse response, R result) { response.setContentType(\"application/json; charset=utf-8\"); OutputStream out = null; try { out = response.getOutputStream(); String str = JSON.toJSONString(result); out.write(str.getBytes(StandardCharsets.UTF_8)); out.flush(); out.close(); } catch (IOException e) { e.printStackTrace(); } 二、基于Redis Zset 结构 以滑动窗口的方式 实现 单位时间内对 接口的限流方案一中有缺陷，所以是针对 ip 进行限流，因为只能 当统计 1- 11秒的时候，没法统计 2-12 秒 就是没法统计 N 秒内 M 个请求(如果要做到 就需要多个key) 基本思路： 使用 Redis 的 Zset 因为 Zset 天然按照 score 进行排序，使用 methodName 作为 Key ，当前时间戳作为 score，在每次查询的时候 动态的维护时间窗口，将不属于 当面限制时间段内的数据给清除，统计属于当前时间段内的次数即可 具体看代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041@Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 判断是否属于方法handler if (handler instanceof HandlerMethod) { // 获取判断是否含有注解 AccessLimit accessLimit = ((HandlerMethod) handler).getMethodAnnotation(AccessLimit.class); // 没有注解标记 直接返回允许通行 if (accessLimit == null) { return true; } // 获取 限流的参数 int maxCount = accessLimit.maxCount(); int seconds = accessLimit.seconds(); 这里区分和方案一不同 --------------- // 获取方法名 这里实现对方法级别的限制访问 String methodName = ((HandlerMethod) handler).getMethod().getName(); // 获取当前时间戳 long nowTime = new Date().getTime(); // 设置方法访问的 时间戳 redisTemplate.opsForZSet().add(methodName, nowTime + \" \", nowTime); // 删除窗口之外的数据 redisTemplate.opsForZSet().removeRangeByScore(methodName, 0, nowTime - seconds * 1000); // 获取窗口内的访问次数 Long count = redisTemplate.opsForZSet().zCard(methodName); ----------------- // 如果超出访问限制 限流 if (count &gt; maxCount) { render(response, new R().fail(\"操作过于频繁,请稍后再试\")); return false; } } return true; }","categories":[{"name":"Redis","slug":"Redis","permalink":"http://colorfuwp.top/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://colorfuwp.top/tags/Redis/"},{"name":"自定义注解","slug":"自定义注解","permalink":"http://colorfuwp.top/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"name":"限流","slug":"限流","permalink":"http://colorfuwp.top/tags/%E9%99%90%E6%B5%81/"}]}],"categories":[{"name":"Redis","slug":"Redis","permalink":"http://colorfuwp.top/categories/Redis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://colorfuwp.top/categories/SpringBoot/"},{"name":"三方包","slug":"三方包","permalink":"http://colorfuwp.top/categories/%E4%B8%89%E6%96%B9%E5%8C%85/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://colorfuwp.top/tags/Spring/"},{"name":"底层原理","slug":"底层原理","permalink":"http://colorfuwp.top/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"Java8","slug":"Java8","permalink":"http://colorfuwp.top/tags/Java8/"},{"name":"Java","slug":"Java","permalink":"http://colorfuwp.top/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://colorfuwp.top/tags/SpringBoot/"},{"name":"自定义注解","slug":"自定义注解","permalink":"http://colorfuwp.top/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"name":"三方包","slug":"三方包","permalink":"http://colorfuwp.top/tags/%E4%B8%89%E6%96%B9%E5%8C%85/"},{"name":"Redis","slug":"Redis","permalink":"http://colorfuwp.top/tags/Redis/"},{"name":"限流","slug":"限流","permalink":"http://colorfuwp.top/tags/%E9%99%90%E6%B5%81/"}]}